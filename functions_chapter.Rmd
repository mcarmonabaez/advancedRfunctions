---
title: "Advanced R: Functions"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r, echo = FALSE}
library(learnr)

```

## 6.1 Quiz

```{r elementos, echo=FALSE}
question("驴Cu谩les son los 3 componentes de una funci贸n?",
  answer("Argumentos, cuerpo, resultado"),
  answer("Argumentos, ambiete, resultado"),
  answer("Cuerpo, argumentos, ambiente", correct = TRUE)
)


```

```{r ex1, exercise = TRUE}
x <- 10
f1 <- function(x) {
  function() {
    x + 10
  }
}
f1(1)()
```

```{r once, echo=FALSE}
question("驴Qu茅 regresa el c贸digo anterior?",
  answer("ERROR"),
  answer("11" , correct = TRUE),
  answer("NA"),
  answer("10")
)
```

```{r ex2, exercise = TRUE}
`+`(1, `*`(2, 3))
```

```{r suma, echo=FALSE}
question("驴C贸mo escribimos este c贸digo normalmente?",
  answer("(1 * 2) + (1 * 3)"),
  answer("1 + (2 * 3)" , correct = TRUE)
)
```

```{r ex3, exercise = TRUE}
mean(, TRUE, x = c(1:10, NA))
```

```{r mean, echo=FALSE}
question("驴C贸mo har铆as que este c贸digo sea m谩s f谩cil de leer?",
  answer("mean( x = c(1:10, NA), na.rm = TRUE)", correct = TRUE),
  answer("mean(TRUE, x = c(1:10, NA))"),
  answer("mean(c(1:10, NA), na.rm = TRUE)", correct = TRUE)
)
```

```{r ex4, exercise = TRUE}
f2 <- function(a, b) {
  a * 10
}
f2(10, stop("This is an error!"))
```

```{r sino, echo=FALSE}
question("驴Regresa un error el c贸digo anterior? 驴Por qu茅?",
  answer("S铆"),
  answer("No" , correct = TRUE)
)
```

## 6.2 Fundamentos de las funciones

Hay 2 cosas importantes para poder entender las funciones.

  1. Las funciones tienen 3 componentes. (Existen casos especiales)
  2. Las funciones son objetos

### 6.2.1 Componentes de las funciones 

Los componentes de una funci贸n son:

  * **Argumentos**: lista de argumentos que controla como se llama la funci贸n 
  * **Cuerpo**: C贸digo a ejecutar 
  * **Ambiente**: Estructura de datos que determina como la funci贸n encuentra los valores asociados a los nombres 


Los argumentos y el cuerpo de la funci贸n son especificados en el momento que escribimos la funci贸n, mientras que el ambiente se especifica de manera impl铆cita, con base en _el lugar_ donde definimos la funci贸n. El ambiente siempre existe.

```{r f621, exercise=TRUE}
# Funci贸n con par谩metros x & y
f02 <- function(x, y) {
  # Suma x & y
  x + y
}
# Argumentos
formals(f02)
# Cuerpo
body(f02)
# Ambiente 
environment(f02)
```


Las funciones tambi茅n pueden  tener  atributos adicionales. Un atributo que nos
puede ayudar a  conocer a m谩s detalle el c贸digo de la funci贸n
es `srcref`. Esta funci贸n dirge al c贸digo fuente usado para crear la funci贸n. 

```{r f6211, exercise=TRUE}
f02 <- function(x, y) {
  # Suma x & y
  x + y
}
#Cuerpo
attr(f02, "srcref")
```


### 6.2.2 Funciones primitivas 
Las funciones primitivas son aquellas que fueron implementadas en  __C__ por lo tanto
cada que son utilizadas llaman codigo de __C__ directamente.

Algunos datos adicionales sobre estas funciones primitivas son:

  * Solo podemos encontrarlas en el paquete base.
  * formals(), body()  y environment() son NULL
  * Son objetos de tipo 'builtin' o 'special'

```{r f622, exercise=TRUE}
typeof(sum)
formals(sum)
#> NULL
body(sum)
#> NULL
environment(sum)
#> NULL

```
### 6.2.3 Funciones de primera clase

A diferencia de otros lenguajes, no hay una sint谩xis especial para definir y nombrar
una funci贸n, simplemente se crea un objeto tipo funci贸n (con `function`) y lo vinculamos
a un nombre con `<-`.

```{r f623, exercise=TRUE}
f01 <- function(x) {
  sin(1 / x ^ 2)
}
f01(1)
```

No es necesario siempre vinvular una funci贸n a un nombre, podemos crear __funciones an贸nimas__.

```{r f6232, exercise=TRUE}
sapply(mtcars, function(x) length(unique(x)))
Filter(function(x) !is.numeric(x), mtcars)
integrate(function(x) sin(x) ^ 2, 0, pi)
```

Tambi茅n podemos guardar funciones en listas 

```{r f6233, exercise=TRUE}
funs <- list(
  half = function(x) x / 2,
  double = function(x) x * 2
)

funs$double(10)
#> [1] 20
```

### 6.2.4 Invocar una funci贸n  

Normalmente podemos llamar a una funci贸n poniendo sus argumentos entre par茅ntesis despu茅s de su nombre.
Pero, 驴qu茅 pasa si los argumentos ya se encuentran dentro de una estructura de datos? 隆Podemos 
utilizar `do.call()`!

`do.call()` tiene dos argumentos: el nombre de la funci贸n y una lista con los argumentos de dicha funci贸n.

```{r f624, exercise=TRUE}
args <- list(1:10, na.rm = TRUE)
do.call(mean, args)
#> [1] 5.5
```

### 6.2.5 Ejercicios


## 6.3 Composici贸n de funciones

**R** base nos da dos formas de realizar composiciones de llamadas de m煤ltiples funciones:
anidando o guardando los resultados intermedios.

El paquete magrittr nos da una tercera opci贸n con el operador `%>%`, llamado _pipe_ y
se pronuncia "y luego".

Por ejemplo, si quisi茅ramos calcular la desviaci贸n est谩ndar por pasos usando `mean` y `sqrt`, tendr铆amos lo siguiente:

```{r f63, exercise=TRUE}
square <- function(x) x^2
deviation <- function(x) x - mean(x)

# Funciones anidadas
x <- runif(100)

sqrt(mean(square(deviation(x))))
#> [1] 0.274

# Guardando los resultados intermedios
out <- deviation(x)
out <- square(out)
out <- mean(out)
out <- sqrt(out)
out
#> [1] 0.274

# Usando pipe
library(magrittr)

x %>%
  deviation() %>%
  square() %>%
  mean() %>%
  sqrt()
#> [1] 0.274

```

`x %>% f()` es equivalente a `f(x)` y `x %>% f(y)` es equivalente a `f(x, y)`.

Cada una de las opciones de composici贸n tiene ventajas y desventajas:

  * __Anidado__ `f(g(x))`: es ideal para seciencias cortas. Sin embargo, en secuencias largas
  puede resultar confuso pues se leen de adentro hacia afuera y de derecha a izquierda. Puede
  crear un problema del _sandwich de Dagwood_ オ.
  * __Objetos intermedios__ `y <- f(x); g(y)`: requiere que nombremos todos los objetos intermedios.
  Puede ser 煤til si estos objetos son importantes, pero de poca ayuda si solo son realmente intermedios.
  * __Piping__  `x %>% f() %>% g()`: nos ayuda a leer el c贸digo de izquierda a derecha sin necesidad de 
  nombrar objetos intermedios. Sin embargo, solo se aplica en secuencias lineales donde se transforma un solo objeto
  y estamos asumiendo que el lector entiende la nomenclatura.
  

## 6.4 Alcance l茅xico

Con __alcance__ nos referimos a el acto de encontrar el valor asociado a un nombre.

驴Qu茅 regresa el siguiente c贸digo?

```{r f64, exercise=TRUE}
x <- 10
g01 <- function() {
  x <- 20
  x
}

g01()
```

A nivel lenguaje, **R** usa __alcance l茅xico__ (_lexical scoping_), esto implica que va a buscar los valores asociados a un nombre bas谩ndose en c贸mo la funci贸n es definida y no en c贸mo es nombrada.

El alcance l茅xico en R sigue las siguientes reglas:

  * Enmascaramiento de nombres o _name masking_ 
  * Funciones vs variables
  * Un nuevo comienzo
  * B铆squeda din谩mica
  
### 6.4.1 Enmascaramiento de nombres ジ

Los nombres definidos dentro de una funci贸n enmascaran los nombres definidos fuera de la funci贸n. Ejemplo:


```{r f641, exercise=TRUE}
x <- 10
y <- 20
g02 <- function() {
  x <- 1
  y <- 2
  c(x, y)
}
g02()
#> [1] 1 2
```

Si un nombre no est谩 definido dentro de una funci贸n, **R** lo va a buscar un nivel arriba.

```{r f6412, exercise=TRUE}
x <- 2
g03 <- function() {
  y <- 1
  c(x, y)
}
g03()
#> [1] 2 1

# Esto no afecta el valor de y
y
#> [1] 20
```

Las mismas reglas se cumplen si una funci贸n es definida dentro de otra funci贸n. Primero, R va a buscar dentro
de la funci贸n actual. Despu茅s, va a buscar en donde esa funci贸n fue definida (y as铆 hasta llegar al ambiente global).
Finalmente, busca en otros paquetes cargados.

驴Qu茅 crees que regresa el siguiente c贸digo?

```{r f6413, exercise=TRUE}
x <- 1
g04 <- function() {
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}
g04()
```

### 6.4.2 Funciones vs Variables 锔

En R, las funciones son objetos comunes. Esto significa que las reglas descritas anteriormente tambi茅n
se cumplen para funciones.

```{r f642, exercise=TRUE}
g07 <- function(x) x + 1
g08 <- function() {
  g07 <- function(x) x + 100
  g07(10)
}
g08()
#> [1] 110
```
No obstante, cuando una funci贸n y un objeto que no es funci贸n comparten el mismo nombre (deben de estar en
ambientes diferentes), seguir estas reglas se vuelve un poco complicado. Cuando usas un nombre como funci贸n,
R ignora los objetos que no son funciones cuando busca el valor asignado.

```{r f6422, exercise=TRUE}
g09 <- function(x) x + 100
g10 <- function() {
  g09 <- 10
  g09(g09)
}
g10()
#> [1] 110
```


**Importante**: evita usar el mismo nombre para objetos distintos. 锔锔

### 6.4.3 Un nuevo comienzo 

```{r e643, exercise=TRUE}
g11 <- function() {
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  a
}
# Ejecuci贸n 1
g11()
# Ejecuci贸n 2
g11()
```

```{r ex643, echo=FALSE}
question("驴Cu谩l es el resultado al llamar la funcion dos veces?",
  answer("El resultado en ambas ejecuciones es el mismo", correct = TRUE),
  answer("El resultado en la segunda ejecuciones es m谩s grande"),
  answer("El resultado en la primera ejecuciones es m谩s grande")
)
```

Algo importante que  necesitamos saber es que cada que las funciones son ejecutadas  un nuevo ambiente es creado para permitir la ejecuci贸n de la funci贸n. Por lo tanto no podemos saber que paso en la ejecuci贸n anterior ya que cada ejecuci贸n es independiente. 

### 6.4.4 B煤squeda din谩mica

El resultado de ejecutar una funci贸n puede  ser  diferente dependiendo de los objetos fuera del entorno,  ya que R busca los valores  cuando se ejecuta la funci贸n no cuando la creamos y el alcance l茅xico determina donde pero no cuando buscar los valores. 

```{r e644, exercise=TRUE}
g12 <- function() x + 1
x <- 15
g12()
#> [1] 16

x <- 20
g12()
#> [1] 21
```

Lo anterior puede ser un  problema cuando ejecutamos la funci贸n, ya que si no tenemos bien claro todo el ambiente en el  que esta corriendo la funci贸n podemos tener un resultado no esperado. 

Para poder saber las dependencias externas dentro de una funci贸n podemos utilizar __codetools::findGlobals()__.

```{r e6441, exercise=TRUE}
codetools::findGlobals(g12)
#> [1] "+" "x"
```

Para poder controlar las dependencias externas podemos cambiar el ambiente de la funci贸n manualmente a un ambiente que no contiene nada con la funci贸n __emptyenv()__.

```{r e6442, exercise=TRUE}
environment(g12) <- emptyenv()
g12()
```

**Nota**: __R__ se basa  en el alcance l茅xico para encontrar todo.

## 6.5 Lazy evaluation

En __R__ los argumentos de una funci贸n son evaluados s贸lo si se utilizan.
```{r e65, exercise=TRUE}
h01 <- function(x) {
  10
}
h01(stop("This is an error!"))
```

### 6.5.1 Promesas

Lazy evaluations son posibles gracias a una estructura de datos llamada __Promesa__. Las promesas tienen 3 componentes:

1. Una expresi贸n (x+y la cu谩l da lugar al c贸mputo diferido)
2. Un ambiente (donde la expresion ser谩 evaluada)
3. Un valor (que se calcula y se almacena en cach茅 la  primera vez que se accede a una promesa cuando la expresi贸n es evaluada en el ambiente)

```{r e651, exercise=TRUE}
y <- 10
h02 <- function(x) {
  y <- 100
  x + 1
}
# Ejemplo 1
h02(y)
#Ejemplo 2
h02(y <- 1000)
#Ejemplo 3
y
```

Con lo anterior podemos ver que cuando se hace una asignaci贸n dentro de una llamada a una funci贸n, la variable est谩 ligada fuera de la funci贸n, no dentro de ella (Ejemplo 1 y 2).

**Nota** Lass promesas no pueden ser manipuladas con c贸digo de R ya que si lo haces la promesa se evaluar谩 y desaparecer谩. Para poder explorar las promesas se puede utilizar __quosures__. Este tema se ver谩 en la secci贸n 20. 

### 6.5.2 Argumentos por defecto

