---
title: "Advanced R: Funciones"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---

```{r, echo = FALSE}
library(learnr)

```

## 6.1 Quiz üéØ

```{r elementos, echo=FALSE}
question("¬øCu√°les son los 3 componentes de una funci√≥n?",
  answer("Argumentos, cuerpo, resultado"),
  answer("Argumentos, ambiete, resultado"),
  answer("Cuerpo, argumentos, ambiente", correct = TRUE)
)


```

```{r ex1, exercise = TRUE}
x <- 10
f1 <- function(x) {
  function() {
    x + 10
  }
}
f1(1)()
```

```{r once, echo=FALSE}
question("¬øQu√© regresa el c√≥digo anterior?",
  answer("ERROR"),
  answer("11" , correct = TRUE),
  answer("NA"),
  answer("10")
)
```

```{r ex2, exercise = TRUE}
`+`(1, `*`(2, 3))
```

```{r suma, echo=FALSE}
question("¬øC√≥mo escribimos este c√≥digo normalmente?",
  answer("(1 * 2) + (1 * 3)"),
  answer("1 + (2 * 3)" , correct = TRUE)
)
```

```{r ex3, exercise = TRUE}
mean(, TRUE, x = c(1:10, NA))
```

```{r mean, echo=FALSE}
question("¬øC√≥mo har√≠as que este c√≥digo sea m√°s f√°cil de leer?",
  answer("mean( x = c(1:10, NA), na.rm = TRUE)", correct = TRUE),
  answer("mean(TRUE, x = c(1:10, NA))"),
  answer("mean(c(1:10, NA), na.rm = TRUE)", correct = TRUE)
)
```

```{r ex4, exercise = TRUE}
f2 <- function(a, b) {
  a * 10
}
f2(10, stop("This is an error!"))
```

```{r sino, echo=FALSE}
question("¬øRegresa un error el c√≥digo anterior? ¬øPor qu√©?",
  answer("S√≠"),
  answer("No" , correct = TRUE)
)
```

## 6.2 Fundamentos de las funciones üèóÔ∏è

Hay 2 cosas importantes para poder entender las funciones.

  1. Las funciones tienen 3 componentes. (Existen casos especiales)
  2. Las funciones son objetos

### 6.2.1 Componentes de las funciones 

Los componentes de una funci√≥n son:

  * **Argumentos**: lista de argumentos que controla como se llama la funci√≥n 
  * **Cuerpo**: C√≥digo a ejecutar 
  * **Ambiente**: Estructura de datos que determina como la funci√≥n encuentra los valores asociados a los nombres 


Los argumentos y el cuerpo de la funci√≥n son especificados en el momento que escribimos la funci√≥n, mientras que el ambiente se especifica de manera impl√≠cita, con base en _el lugar_ donde definimos la funci√≥n. El ambiente siempre existe.

```{r f621, exercise=TRUE}
# Funci√≥n con par√°metros x & y
f02 <- function(x, y) {
  # Suma x & y
  x + y
}
# Argumentos
formals(f02)
# Cuerpo
body(f02)
# Ambiente 
environment(f02)
```


Las funciones tambi√©n pueden  tener  atributos adicionales. Un atributo que nos
puede ayudar a  conocer a m√°s detalle el c√≥digo de la funci√≥n
es `srcref`. Esta funci√≥n dirge al c√≥digo fuente usado para crear la funci√≥n. 

```{r f6211, exercise=TRUE}
f02 <- function(x, y) {
  # Suma x & y
  x + y
}
#Cuerpo
attr(f02, "srcref")
```


### 6.2.2 Funciones primitivas 
Las funciones primitivas son aquellas que fueron implementadas en  __C__ por lo tanto
cada que son utilizadas llaman codigo de __C__ directamente.

Algunos datos adicionales sobre estas funciones primitivas son:

  * Solo podemos encontrarlas en el paquete base.
  * `formals()`, `body()`  y `environment()` son NULL
  * Son objetos de tipo 'builtin' o 'special'

```{r f622, exercise=TRUE}
typeof(sum)
formals(sum)
#> NULL
body(sum)
#> NULL
environment(sum)
#> NULL

```
### 6.2.3 Funciones de primera clase

A diferencia de otros lenguajes, no hay una sint√°xis especial para definir y nombrar
una funci√≥n, simplemente se crea un objeto tipo funci√≥n (con `function`) y lo vinculamos
a un nombre con `<-`.

```{r f623, exercise=TRUE}
f01 <- function(x) {
  sin(1 / x ^ 2)
}
f01(1)
```

No es necesario siempre vinvular una funci√≥n a un nombre, podemos crear __funciones an√≥nimas__ ü§´.

```{r f6232, exercise=TRUE}
sapply(mtcars, function(x) length(unique(x)))
Filter(function(x) !is.numeric(x), mtcars)
integrate(function(x) sin(x) ^ 2, 0, pi)
```

Tambi√©n podemos guardar funciones en listas üò≤

```{r f6233, exercise=TRUE}
funs <- list(
  half = function(x) x / 2,
  double = function(x) x * 2
)

funs$double(10)
#> [1] 20
```

### 6.2.4 Invocar una funci√≥n üëª 

Normalmente podemos llamar a una funci√≥n poniendo sus argumentos entre par√©ntesis despu√©s de su nombre.
Pero, ¬øqu√© pasa si los argumentos ya se encuentran dentro de una estructura de datos? ¬°Podemos 
utilizar `do.call()`!

`do.call()` tiene dos argumentos: el nombre de la funci√≥n y una lista con los argumentos de dicha funci√≥n.

```{r f624, exercise=TRUE}
args <- list(1:10, na.rm = TRUE)
do.call(mean, args)
#> [1] 5.5
```



## 6.3 Composici√≥n de funciones

**R** base nos da dos formas de realizar composiciones de llamadas de m√∫ltiples funciones:
anidando üê£ o guardando los resultados intermedios üîí.

El paquete magrittr nos da una tercera opci√≥n con el operador `%>%`, llamado _pipe_ y
se pronuncia "y luego".

Por ejemplo, si quisi√©ramos calcular la desviaci√≥n est√°ndar por pasos usando `mean` y `sqrt`, tendr√≠amos lo siguiente:

```{r f63, exercise=TRUE}
square <- function(x) x^2
deviation <- function(x) x - mean(x)

# Funciones anidadas
x <- runif(100)

sqrt(mean(square(deviation(x))))
#> [1] 0.274

# Guardando los resultados intermedios
out <- deviation(x)
out <- square(out)
out <- mean(out)
out <- sqrt(out)
out
#> [1] 0.274

# Usando pipe
library(magrittr)

x %>%
  deviation() %>%
  square() %>%
  mean() %>%
  sqrt()
#> [1] 0.274

```

`x %>% f()` es equivalente a `f(x)` y `x %>% f(y)` es equivalente a `f(x, y)`.

Cada una de las opciones de composici√≥n tiene ventajas y desventajas:

  * __Anidado__ `f(g(x))`: es ideal para seciencias cortas. Sin embargo, en secuencias largas
  puede resultar confuso pues se leen de adentro hacia afuera y de derecha a izquierda. Puede
  crear un problema del _sandwich de Dagwood_ ü•™.
  * __Objetos intermedios__ `y <- f(x); g(y)`: requiere que nombremos todos los objetos intermedios.
  Puede ser √∫til si estos objetos son importantes, pero de poca ayuda si solo son realmente intermedios.
  * __Piping__  `x %>% f() %>% g()`: nos ayuda a leer el c√≥digo de izquierda a derecha sin necesidad de 
  nombrar objetos intermedios. Sin embargo, solo se aplica en secuencias lineales donde se transforma un solo objeto
  y estamos asumiendo que el lector entiende la nomenclatura.
  

## 6.4 Alcance l√©xico

Con __alcance__ nos referimos a el acto de encontrar el valor asociado a un nombre.

¬øQu√© regresa el siguiente c√≥digo?

```{r f64, exercise=TRUE}
x <- 10
g01 <- function() {
  x <- 20
  x
}

g01()
```

A nivel lenguaje, **R** usa __alcance l√©xico__ (_lexical scoping_), esto implica que va a buscar los valores asociados a un nombre bas√°ndose en c√≥mo la funci√≥n es definida y no en c√≥mo es nombrada.

El alcance l√©xico en R sigue las siguientes reglas:

  * Enmascaramiento de nombres o _name masking_ 
  * Funciones vs variables
  * Un nuevo comienzo
  * B√∫squeda din√°mica
  
### 6.4.1 Enmascaramiento de nombres ü•∏

Los nombres definidos dentro de una funci√≥n enmascaran los nombres definidos fuera de la funci√≥n. Ejemplo:


```{r f641, exercise=TRUE}
x <- 10
y <- 20
g02 <- function() {
  x <- 1
  y <- 2
  c(x, y)
}
g02()
#> [1] 1 2
```

Si un nombre no est√° definido dentro de una funci√≥n, **R** lo va a buscar un nivel arriba.

```{r f6412, exercise=TRUE}
x <- 2
g03 <- function() {
  y <- 1
  c(x, y)
}
g03()
#> [1] 2 1

# Esto no afecta el valor de y
y
#> [1] 20
```

Las mismas reglas se cumplen si una funci√≥n es definida dentro de otra funci√≥n. Primero, R va a buscar dentro
de la funci√≥n actual. Despu√©s, va a buscar en donde esa funci√≥n fue definida (y as√≠ hasta llegar al ambiente global).
Finalmente, busca en otros paquetes cargados.

¬øQu√© crees que regresa el siguiente c√≥digo?

```{r f6413, exercise=TRUE}
x <- 1
g04 <- function() {
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}
g04()
```

### 6.4.2 Funciones vs Variables ‚öîÔ∏è

En R, las funciones son objetos comunes. Esto significa que las reglas descritas anteriormente tambi√©n
se cumplen para funciones.

```{r f642, exercise=TRUE}
g07 <- function(x) x + 1
g08 <- function() {
  g07 <- function(x) x + 100
  g07(10)
}
g08()
#> [1] 110
```
No obstante, cuando una funci√≥n y un objeto que no es funci√≥n comparten el mismo nombre (deben de estar en
ambientes diferentes), seguir estas reglas se vuelve un poco complicado. Cuando usas un nombre como funci√≥n,
R ignora los objetos que no son funciones cuando busca el valor asignado.

```{r f6422, exercise=TRUE}
g09 <- function(x) x + 100
g10 <- function() {
  g09 <- 10
  g09(g09)
}
g10()
#> [1] 110
```


**Importante**: evita usar el mismo nombre para objetos distintos. ‚ò†Ô∏è‚ò†Ô∏è

### 6.4.3 Un nuevo comienzo üå§Ô∏è

```{r e643, exercise=TRUE}
g11 <- function() {
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  a
}
# Ejecuci√≥n 1
g11()
# Ejecuci√≥n 2
g11()
```

```{r ex643, echo=FALSE}
question("¬øCu√°l es el resultado al llamar la funcion dos veces?",
  answer("El resultado en ambas ejecuciones es el mismo", correct = TRUE),
  answer("El resultado en la segunda ejecuciones es m√°s grande"),
  answer("El resultado en la primera ejecuciones es m√°s grande")
)
```

‚ö° Algo importante que  necesitamos saber es que cada que las funciones son ejecutadas  un nuevo ambiente es creado para permitir la ejecuci√≥n de la funci√≥n. Por lo tanto no podemos saber qu√© paso en la ejecuci√≥n anterior ya que cada ejecuci√≥n es independiente. 

### 6.4.4 B√∫squeda din√°mica üîç

El resultado de ejecutar una funci√≥n puede  ser  diferente dependiendo de los objetos fuera del entorno,  ya que R busca los valores  cuando se ejecuta la funci√≥n no cuando la creamos y el alcance l√©xico determina donde pero no cuando buscar los valores. 

```{r e644, exercise=TRUE}
g12 <- function() x + 1
x <- 15
g12()
#> [1] 16

x <- 20
g12()
#> [1] 21
```

Lo anterior puede ser un  problema cuando ejecutamos la funci√≥n, ya que si no tenemos bien claro todo el ambiente en el  que esta corriendo la funci√≥n podemos tener un resultado no esperado. üòï

Para poder saber las dependencias externas dentro de una funci√≥n podemos utilizar `codetools::findGlobals()`.

```{r e6441, exercise=TRUE}
codetools::findGlobals(g12)
#> [1] "+" "x"
```

Para poder controlar las dependencias externas podemos cambiar el ambiente de la funci√≥n manualmente a un ambiente que no contiene nada con la funci√≥n `emptyenv()`.

```{r e6442, exercise=TRUE}
environment(g12) <- emptyenv()
g12()
```

**Nota**: __R__ se basa  en el alcance l√©xico para encontrar todo.‚≠ê

## 6.5 Evaluaci√≥n no estricta (_lazy evaluation_) ü¶•

En __R__ los argumentos de una funci√≥n son evaluados s√≥lo si se utilizan.
```{r e65, exercise=TRUE}
h01 <- function(x) {
  10
}
h01(stop("This is an error!"))
```

### 6.5.1 Promesas

Lazy evaluations son posibles gracias a una estructura de datos llamada __promesa__ üîÆ. Las promesas tienen 3 componentes:

1. Una expresi√≥n (x+y la cu√°l da lugar al c√≥mputo diferido)
2. Un ambiente (donde la expresion ser√° evaluada)
3. Un valor (que se calcula y se almacena en cach√© la  primera vez que se accede a una promesa cuando la expresi√≥n es evaluada en el ambiente)

```{r e651, exercise=TRUE}
y <- 10
h02 <- function(x) {
  y <- 100
  x + 1
}
# Ejemplo 1
h02(y)
#Ejemplo 2
h02(y <- 1000)
#Ejemplo 3
y
```

Con lo anterior podemos ver que cuando se hace una asignaci√≥n dentro de una llamada a una funci√≥n, la variable est√° ligada fuera de la funci√≥n, no dentro de ella (Ejemplo 1 y 2).

**Nota** Las promesas no pueden ser manipuladas con c√≥digo de R ya que si lo haces la promesa se evaluar√° y desaparecer√°. Para poder explorar las promesas se puede utilizar __quosures__. Este tema se ver√° en la secci√≥n 20. 

### 6.5.2 Argumentos por defecto

En las funciones es posible tener valores por defecto basados en otros argumentos o en variables definidas despu√©s dentro de  la funci√≥n. 

```{r e652, exercise=TRUE}
h04 <- function(x = 1, y = x * 2, z = a + b) {
  a <- 10
  b <- 100
  
  c(x, y, z)
}

h04()
```

**Nota** Lo anterior puede ser un poco confuso y recomendamos utilizarlo con precauci√≥n ‚ò†Ô∏è

El ambiente en que evaluamos los  argumentos por defecto y los que el usuario nos da pueden ser diferentes, ya que los argumentos por defecto se evaluar√°n dentro de la funci√≥n y los dados por el usuario fuera.

```{r e6522, exercise=TRUE}
h05 <- function(x = ls()) {
  a <- 1
  x
}

# ls() evaluado dentro de h05:
h05()
# ls() evaluado en el ambiente global:
h05(ls())
```

### 6.5.3 Argumentos faltantes ‚ùì

Para ver si el valor de un argumento proviene del usuario o de un valor por defecto (_default_), 
podemos usar `missing()`.

```{r e6523, exercise=TRUE}
h06 <- function(x = 10) {
  list(missing(x), x)
}
str(h06())
#> List of 2
#>  $ : logi TRUE
#>  $ : num 10
str(h06(10))
#> List of 2
#>  $ : logi FALSE
#>  $ : num 10
```


Es mejor solo usar `missing()` cuando es necesario. Tomemos `sample()` como un ejemplo.
¬øCu√°ntos argumentos requiere?



```{r e65232, exercise=TRUE}
args(sample)
#> function (x, size, replace = FALSE, prob = NULL) 
#> NULL
```

A simple vista parece que `x` y `size` son necesarios, pero si no damos un valor a
`size`, `sample()` usa `missing()` para dar un valor. Una manera de reescribir `sample` 
ser√≠a especificando que `size` no es necesario pero podemos darle un valor.


```{r e65233, exercise=TRUE}
sample <- function(x, size = NULL, replace = FALSE, prob = NULL) {
  if (is.null(size)) {
    size <- length(x)
  }
  
  x[sample.int(length(x), size, replace = replace, prob = prob)]
}
```


Podr√≠amos simplificar a√∫n m√°s la funci√≥n usando el patr√≥n binario creado por la funci√≥n infix
`%||%`, la cual usa el lado izquierdo sino es `NULL` y el lado derecho en otro caso.

```{r e652332, exercise=TRUE}
`%||%` <- function(lhs, rhs) {
  if (!is.null(lhs)) {
    lhs
  } else {
    rhs
  }
}

sample <- function(x, size = NULL, replace = FALSE, prob = NULL) {
  size <- size %||% length(x)
  x[sample.int(length(x), size, replace = replace, prob = prob)]
}
```

Gracias a la evaluaci√≥n no estricta, no necesitamos preocuparnos de c√°lculos innecesarios.
El lado derecho solo ser√° evaluado si el lado izquierdo es `NULL`. üòå

## 6.6 `...` (punto-punto-punto)

Las funciones pueden tener un argumento especial `...`, con el cual una funci√≥n puede tomar
cualquier n√∫mero de argumentos adicionales. Este tipo de argumento suele ser llamado _varargs_
(argumentos variables). Una funci√≥n que usa este argumento es llamada _vari√°dica_.

Tambi√©n se puede usar `...` para pasarle esos argumentos adicionales a otra funci√≥n.


```{r e66, exercise=TRUE}
i01 <- function(y, z) {
  list(y = y, z = z)
}

i02 <- function(x, ...) {
  i01(...)
}

str(i02(x = 1, y = 2, z = 3))
#> List of 2
#>  $ y: num 2
#>  $ z: num 3
```

Existe la forma especial  `..N` (casi no se usa), para referirse a los elementos por su posici√≥n.

```{r e662, exercise=TRUE}
i03 <- function(...) {
  list(first = ..1, third = ..3)
}
str(i03(1, 2, 3))
#> List of 2
#>  $ first: num 1
#>  $ third: num 3
```

Es m√°s √∫til `list(...)`, que eval√∫a los argumentos y los guarda en una lista. ü§Ø

```{r e663, exercise=TRUE}
i04 <- function(...) {
  list(...)
}
str(i04(a = 1, b = 2))
#> List of 2
#>  $ a: num 1
#>  $ b: num 2
```

Hay dos usos principales para `...`:

  - Si tu funci√≥n usa una funci√≥n como argumento, necesitamos una manera de pasarle los 
  argumentos adicionales a esa funci√≥n. En este ejemplo `lapply()` utiliza `...` para pasar `na.rm` a `mean()`:
  
```{r e664, exercise=TRUE}
x <- list(c(1, 3, NA), c(4, NA, 6))
str(lapply(x, mean, na.rm = TRUE))
#> List of 2
#>  $ : num 2
#>  $ : num 5
```  

  - Si una funci√≥n es S¬∑ gen√©rica, necesitas una manera de permitir que los m√©todos acepten argumentos arbitrarios extra. En el caso de `print()`, como hay muchas maneras para imprimir dependiendo del tipo de objeto, no hay una manera de especificar todos los posibles argumentos y `...` permite tener argumentos diferentes a los m√©todos individuales.
  
```{r e665, exercise=TRUE}
print(factor(letters), max.levels = 4)

print(y ~ x, showEnv = TRUE)
```    
  
Sin embargo, usar `...` tiene dos desventajas üòü:

  - Cuando le pasas los argumentos a otra funci√≥n, tienes que tener cuidado de explicar al usuario a d√≥nde es que van esos argumentos. Esto puede hacer complicado usar funciones como `lapply()` y `plot`.
  - Un argumento mal escrito no va a generar un error. Esto hace m√°s f√°cil que errores de dedo pasen desapercibidos.
  
```{r e666, exercise=TRUE}
sum(1, 2, NA, na_rm = TRUE)
#> [1] NA
```    
